About this week's PINN work:
	This week's PINN mainly tackles basic control work in Gazebo, and does not involve neural network development for the time being. Because our project needs to control turtlebot3's attitude by torque, but Gazebo defaults don't provide a way for torque control (the usual Turtlebot3 control is done via robot Linear velocity and Angular velocity)

(1) So I chose to call the ROS2 service /apply_joint_effort for moment control. Also since the velocity masking effect of the libgazebo_ros_diff_drive.so plugin overrides the moment effect, I commented out the relevant part of this plugin in the sdf file for turtlebot3_burger. This will ensure the normal moment effect process.

(2) After this modification was completed, I found that turtlebot3 still could not move. When browsing the sdf file, I found that the μ value of the default joint is abnormally large (the default value is μ=10000), I reduced this μ value to the normal value range (corrected to μ=0.5), and sent the /apply_joint_effort service call command to ROS via teminal. at this time, the turtlebot3 shows the moment action, and the cart flips over and flies out of the vehicle because of the moment action. torque action flips over and flies out. Although the state is not controllable, the feasibility of torque control is verified.

(3) Next, I tried to maintain a normal attitude by increasing the friction coefficient (increasing μ from 0.5 to 1) and decreasing the torque (decreasing the torque from 20 to 1). Through many experiments, the state of turtlebot3 at this point changed to a back-and-forth flip after the torque was applied, and it flipped for a period of time before it flew out, rather than flying out at the beginning.

(4) In the above process, I found that for the default torque command, the robot will only take effect when the Gazebo is just started, and after a period of time, the Gazebo will not respond to the torque service request. After several times of checking and testing, I realized that the starting_time of the torque service corresponds to the simulation time of Gazebo.

(5) Having solved the time problem, I needed to make turtlebot3 as controllable as possible. By monitoring the /joint_states topic, I realized that the moment invocation service does not zero out after the moment duration, which later tests showed was the key to the improper motion of turtlebot3. At this point the torque was reset by manually adding the torque to 0 after the end of the torque action respectively. In this case, the turtlebot3's performance was greatly improved and no more flying out occurred.

(6) At this point, I considered that in the actual control, if we need to realize the turtlebot3 to turn or rotate in place, we need to apply different torque to the two wheels, and may even need to apply different time to satisfy the demand of turning in complex situations. This required me to transfer the torque parameters originally applied in terminal to python for control. I used MultiThreadedExecutor for parallel two-threaded control of both wheels. And asynchronously control the moment zeroing of both wheels (due to different action times).

The result so far is that turtlebot3 can run in a controlled manner, but is still unable to overcome inertia to stop as soon as the moment effect is over (since applying 0 moment does not limit speed). As I mentioned at the beginning, this phase of work on the PINN subsystem is focused on modifications to the classic Gazebo that allow the Gazebo environment to fulfill the basic requirements of PINN.
